# Comprehensive Token Integration Guide\n\n## Overview\n\nThis guide shows how to integrate the new comprehensive token counting system into MainActivity to replace the existing basic token counting. The key requirement is **conversation resumption with exact token preservation**.\n\n## Key Components\n\n1. **ComprehensiveFileTokenCounter** - Counts tokens for all file types (images, PDFs, documents)\n2. **PreciseContextWindowManager** - Manages context window calculations with all token types\n3. **ConversationTokenManager** (Enhanced) - Handles database persistence and token state\n4. **ComprehensiveTokenIntegration** - Easy-to-use integration helper for MainActivity\n\n## Integration Steps\n\n### 1. Initialize in MainActivity\n\n```kotlin\nclass MainActivity : BaseThemedActivity() {\n    \n    // Add comprehensive token integration\n    private lateinit var comprehensiveTokenIntegration: ComprehensiveTokenIntegration\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Initialize after conversationTokenManager and database are ready\n        comprehensiveTokenIntegration = ComprehensiveTokenIntegration(\n            context = this,\n            conversationTokenManager = conversationTokenManager,\n            conversationDao = appDatabase.conversationDao()\n        )\n        \n        // Schedule background cleanup\n        comprehensiveTokenIntegration.scheduleTokenCleanup(lifecycleScope)\n    }\n}\n```\n\n### 2. Replace Message Validation Logic\n\nReplace the existing `validateMessageBeforeSending()` method:\n\n```kotlin\n// OLD CODE - Replace this:\nprivate suspend fun validateMessageBeforeSending(messageText: String): Boolean {\n    val (exceedsLimit, availableTokens, shouldShowWarning) = \n        conversationTokenManager.wouldExceedLimit(messageText, selectedModelId, billingManager.isSubscribed())\n    \n    if (exceedsLimit) {\n        // Show error dialog\n        return false\n    }\n    return true\n}\n\n// NEW CODE - Use this instead:\nprivate suspend fun validateMessageBeforeSending(\n    messageText: String, \n    selectedFiles: List<Uri> = emptyList()\n): MessageValidationResult {\n    \n    return comprehensiveTokenIntegration.validateMessageBeforeSending(\n        messageText = messageText,\n        selectedFiles = selectedFiles,\n        modelId = selectedModelId,\n        conversationMessages = getCurrentConversationMessages(),\n        isSubscribed = billingManager.isSubscribed(),\n        systemPrompt = getSystemPromptForModel(selectedModelId),\n        webSearchResults = getWebSearchResults() // If using web search\n    )\n}\n```\n\n### 3. Update sendMessage() Method\n\n```kotlin\nprivate suspend fun sendMessage(messageText: String, attachments: List<Uri> = emptyList()) {\n    \n    // Validate message with comprehensive token checking\n    val validationResult = validateMessageBeforeSending(messageText, attachments)\n    \n    when (validationResult) {\n        is MessageValidationResult.Success -> {\n            // Proceed with sending\n            val calculation = validationResult.calculation\n            \n            // Log detailed token info\n            Timber.d(\"Sending message with ${calculation.usage.totalTokens} total tokens (${(calculation.usagePercentage * 100).toInt()}% usage)\")\n            \n            // Send the message (existing logic)\n            val success = sendMessageToAPI(messageText, attachments)\n            \n            if (success) {\n                // Save comprehensive token state after successful send\n                comprehensiveTokenIntegration.saveConversationTokensAfterMessage(\n                    conversationId = currentConversationId,\n                    conversationMessages = getCurrentConversationMessages(),\n                    lastCalculation = calculation\n                )\n            }\n        }\n        \n        is MessageValidationResult.Warning -> {\n            // Show warning dialog but allow proceeding\n            showTokenWarningDialog(\n                message = validationResult.message,\n                onProceed = {\n                    // User chose to continue - send anyway\n                    lifecycleScope.launch {\n                        sendMessageToAPI(messageText, attachments)\n                        comprehensiveTokenIntegration.saveConversationTokensAfterMessage(\n                            conversationId = currentConversationId,\n                            conversationMessages = getCurrentConversationMessages(),\n                            lastCalculation = validationResult.calculation\n                        )\n                    }\n                }\n            )\n        }\n        \n        is MessageValidationResult.Error -> {\n            // Show error dialog - cannot proceed\n            showTokenErrorDialog(validationResult.message)\n        }\n    }\n}\n```\n\n### 4. Update Conversation Loading\n\nReplace conversation loading logic to restore tokens:\n\n```kotlin\n// OLD CODE - Replace this:\nprivate suspend fun loadConversation(conversationId: String) {\n    val messages = chatMessageDao.getMessagesForConversation(conversationId)\n    conversationTokenManager.rebuildFromMessages(messages, conversationId)\n    displayMessages(messages)\n}\n\n// NEW CODE - Use this instead:\nprivate suspend fun loadConversation(conversationId: String) {\n    val messages = chatMessageDao.getMessagesForConversation(conversationId)\n    \n    // Load with comprehensive token restoration\n    val loadResult = comprehensiveTokenIntegration.loadConversationWithTokens(\n        conversationId = conversationId,\n        conversationMessages = messages,\n        modelId = selectedModelId,\n        isSubscribed = billingManager.isSubscribed()\n    )\n    \n    when (loadResult) {\n        is ConversationLoadResult.Success -> {\n            Timber.d(\"Conversation loaded: ${loadResult.message}\")\n            displayMessages(messages)\n            updateTokenCounterUI() // Update UI with restored tokens\n        }\n        is ConversationLoadResult.Warning -> {\n            Timber.w(\"Conversation loaded with warning: ${loadResult.message}\")\n            displayMessages(messages)\n        }\n        is ConversationLoadResult.Error -> {\n            Timber.e(\"Failed to load conversation: ${loadResult.message}\")\n            showErrorDialog(\"Failed to load conversation properly\")\n        }\n    }\n}\n```\n\n### 5. Update Token Counter UI\n\nReplace the existing token counter update:\n\n```kotlin\n// OLD CODE - Replace this:\nprivate fun updateTokenCounter() {\n    TokenCounterHelper.updateTokenCounter(\n        textView = tokenCountTextView,\n        text = currentInputText,\n        modelId = selectedModelId,\n        isSubscribed = billingManager.isSubscribed(),\n        context = this,\n        conversationTokenManager = conversationTokenManager\n    )\n}\n\n// NEW CODE - Use this instead:\nprivate fun updateTokenCounter() {\n    comprehensiveTokenIntegration.updateTokenCounterUI(\n        tokenCounterTextView = tokenCountTextView,\n        modelId = selectedModelId,\n        isSubscribed = billingManager.isSubscribed()\n    )\n}\n```\n\n### 6. Handle Database Migration\n\nThe new system requires database schema updates. Room will handle this automatically, but you may need to increment the database version:\n\n```kotlin\n@Database(\n    entities = [Conversation::class, ChatMessage::class],\n    version = YOUR_CURRENT_VERSION + 1, // Increment version\n    exportSchema = false\n)\nabstract class AppDatabase : RoomDatabase() {\n    // Database will automatically migrate to include new token fields\n}\n```\n\n## Testing the Integration\n\nUse the provided test class to validate everything works:\n\n```kotlin\n// In MainActivity or a test activity\nval test = ComprehensiveTokenTest(this, appDatabase.conversationDao())\nlifecycleScope.launch {\n    test.runAllTests() // This will test conversation resumption\n}\n```\n\n## Key Benefits\n\n### 1. **Exact Conversation Resumption** ✅\n- When you save a conversation and reopen it later, token counts are preserved exactly\n- No more resetting to 0 tokens when reopening conversations\n- Database stores comprehensive token breakdown\n\n### 2. **Accurate File Token Counting** ✅\n- Images: Model-specific calculations (GPT-4: ~765 tokens, Claude: ~1600 tokens)\n- PDFs: Text extraction + image counting\n- Documents: Content extraction and tokenization\n- All file types supported with precise token counts\n\n### 3. **Comprehensive Context Management** ✅\n- Input + Output + File + System + Tool tokens all counted\n- Context window math accounts for ALL token usage\n- Model-specific optimizations and limits\n- Smart response token estimation\n\n### 4. **Better User Experience** ✅\n- Accurate token warnings before sending\n- Detailed token breakdowns in logs\n- Smart recommendations when approaching limits\n- No surprise \"context exceeded\" errors\n\n## Migration Path\n\n1. **Phase 1**: Add new classes alongside existing system\n2. **Phase 2**: Update MainActivity to use ComprehensiveTokenIntegration\n3. **Phase 3**: Test thoroughly with conversation resumption\n4. **Phase 4**: Remove old TokenCounterHelper usage\n5. **Phase 5**: Deploy with database migration\n\n## Troubleshooting\n\n### If tokens don't restore on conversation resumption:\n1. Check database migration completed successfully\n2. Verify conversationId is being passed correctly\n3. Check logs for \"Loaded comprehensive token state\" messages\n4. Ensure saveConversationTokensAfterMessage() is being called\n\n### If file tokens seem incorrect:\n1. Check file type detection in ComprehensiveFileTokenCounter\n2. Verify model-specific calculations are being used\n3. Test with known file sizes\n\n### If context calculations are wrong:\n1. Verify all token types are being included\n2. Check model limits are correct in TokenValidator\n3. Test with different conversation sizes\n\n## Production Checklist\n\n- [ ] Database migration tested\n- [ ] Conversation resumption works correctly  \n- [ ] File token counting accurate for all supported types\n- [ ] Context window calculations include all token types\n- [ ] UI displays comprehensive token information\n- [ ] Background cleanup scheduled\n- [ ] Error handling covers all edge cases\n- [ ] Performance tested with large conversations\n- [ ] Memory usage optimized for token storage\n\nThis comprehensive system ensures that **conversations preserve exact token counts when saved and reopened**, eliminating the issue of tokens resetting to 0 and providing accurate context window management.\n"