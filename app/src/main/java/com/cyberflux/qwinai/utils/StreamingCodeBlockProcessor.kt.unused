package com.cyberflux.qwinai.utils

import android.content.Context
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.TextView
import androidx.core.view.children
import kotlinx.coroutines.*
import timber.log.Timber
import java.util.regex.Pattern

/**
 * Streaming-compatible code block processor that integrates with UltraFastStreamingProcessor
 * Handles code blocks using the custom item_code_block layout while maintaining streaming performance
 */
class StreamingCodeBlockProcessor(private val context: Context) {
    
    private val codeBlockPattern = Pattern.compile("```(\\w*)\\n([\\s\\S]*?)```")
    private val codeBlockManager = CodeBlockViewManager(context)
    
    /**
     * Process text for streaming with code block handling
     * Returns processed text and manages code block views in the background
     */
    suspend fun processStreamingText(
        text: String,
        textView: TextView,
        onCodeBlocksReady: ((List<android.view.View>) -> Unit)? = null
    ): Spanned = withContext(Dispatchers.Default) {
        
        try {
            // Check if text contains code blocks
            val hasCodeBlocks = codeBlockPattern.matcher(text).find()
            
            if (!hasCodeBlocks) {
                // No code blocks - process normally with syntax highlighting for inline code
                return@withContext processInlineCode(text)
            }
            
            // Process with code blocks
            val (processedText, codeViews) = codeBlockManager.processMarkdownWithCodeBlocks(
                text, 
                textView.parent as? ViewGroup
            )
            
            // Update UI on main thread
            withContext(Dispatchers.Main.immediate) {
                onCodeBlocksReady?.invoke(codeViews)
            }
            
            return@withContext processedText
            
        } catch (e: Exception) {
            Timber.e(e, "Error in streaming code block processing")
            return@withContext SpannableStringBuilder(text)
        }
    }
    
    /**
     * Process inline code (single backticks) with syntax highlighting
     */
    private fun processInlineCode(text: String): Spanned {
        val ssb = SpannableStringBuilder(text)
        
        // Pattern for inline code
        val inlineCodePattern = Pattern.compile("`([^`]+)`")
        val matcher = inlineCodePattern.matcher(text)
        
        while (matcher.find()) {
            val code = matcher.group(1) ?: continue
            val start = matcher.start()
            val end = matcher.end()
            
            try {
                // Apply inline code styling
                val highlighted = CodeSyntaxHighlighter.highlight(context, code, "")
                ssb.replace(start, end, highlighted)
            } catch (e: Exception) {
                Timber.w("Inline code highlighting failed: ${e.message}")
            }
        }
        
        return ssb
    }
    
    /**
     * Insert code block views into a container layout
     * Should be called from the main thread after text processing
     */
    fun insertCodeBlocksIntoContainer(
        container: LinearLayout,
        textView: TextView,
        codeViews: List<android.view.View>,
        processedText: String
    ) {
        try {
            // Clear existing code block views
            removeExistingCodeBlocks(container)
            
            // Split text by code block placeholders and insert views
            val parts = processedText.split(Regex("\\[CODE_BLOCK_\\d+\\]"))
            var currentIndex = 0
            
            for (i in parts.indices) {
                // Add text part
                if (parts[i].isNotEmpty()) {
                    // The textView should contain this part
                }
                
                // Add code block view if available
                if (i < codeViews.size) {
                    val codeView = codeViews[i]
                    
                    // Set proper layout parameters
                    val layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                    layoutParams.setMargins(0, 16, 0, 16)
                    codeView.layoutParams = layoutParams
                    
                    // Find insertion point (after textView)
                    val textViewIndex = findTextViewIndex(container, textView)
                    if (textViewIndex != -1) {
                        container.addView(codeView, textViewIndex + 1 + i)
                    } else {
                        container.addView(codeView)
                    }
                }
            }
            
        } catch (e: Exception) {
            Timber.e(e, "Failed to insert code blocks into container")
        }
    }
    
    /**
     * Find the index of the text view in the container
     */
    private fun findTextViewIndex(container: LinearLayout, textView: TextView): Int {
        container.children.forEachIndexed { index, child ->
            if (child == textView) {
                return index
            }
        }
        return -1
    }
    
    /**
     * Remove existing code block views from container
     */
    private fun removeExistingCodeBlocks(container: LinearLayout) {
        val viewsToRemove = mutableListOf<android.view.View>()
        
        container.children.forEach { child ->
            if (child.tag == "code_block_view") {
                viewsToRemove.add(child)
            }
        }
        
        viewsToRemove.forEach { container.removeView(it) }
    }
    
    /**
     * Simple approach: Replace code blocks with styled text blocks
     * This maintains compatibility with existing TextView-based rendering
     */
    fun processCodeBlocksAsStyledText(text: String): Spanned {
        val ssb = SpannableStringBuilder()
        val matcher = codeBlockPattern.matcher(text)
        var lastEnd = 0
        
        while (matcher.find()) {
            // Add text before code block
            ssb.append(text.substring(lastEnd, matcher.start()))
            
            val language = matcher.group(1) ?: ""
            val code = matcher.group(2)?.trim() ?: ""
            
            // Create styled code block text
            ssb.append("\n\n")
            
            // Language header
            if (language.isNotEmpty()) {
                ssb.append("[$language]\n")
            }
            
            // Code content with syntax highlighting
            try {
                val highlighted = CodeSyntaxHighlighter.highlight(context, code, language)
                ssb.append(highlighted)
            } catch (e: Exception) {
                ssb.append(code)
            }
            
            ssb.append("\n\n")
            
            lastEnd = matcher.end()
        }
        
        // Add remaining text
        if (lastEnd < text.length) {
            ssb.append(text.substring(lastEnd))
        }
        
        return ssb
    }
    
    /**
     * Clean up resources
     */
    fun cleanup() {
        codeBlockManager.cleanup()
    }
}

/**
 * Extension function for UltraFastStreamingProcessor integration
 */
suspend fun String.processWithCodeBlocks(
    context: Context,
    textView: TextView,
    onCodeBlocksReady: ((List<android.view.View>) -> Unit)? = null
): Spanned {
    val processor = StreamingCodeBlockProcessor(context)
    return processor.processStreamingText(this, textView, onCodeBlocksReady)
}